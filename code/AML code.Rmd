---
title: "AML code"
output: html_document
date: "2024-11-03"
---

Exploring transcript data profile of healthy and AML patient samples
## Loading the required libraries
```{r}

library(ggplot2)
library(tximport)
library(tidyverse)
library(DESeq2)
library(RColorBrewer)
library(pheatmap)
```
## Loading the data

Prepare the sample table of the experiment and load quant data generated
by Salmon into R
```{r}
sample_table <- read_csv("../data/SRP518774_metadata.txt") %>%
  filter(`Assay Type` == "RNA-Seq") %>%
  select(`Run`, `isolate`) %>%
  mutate(condition = if_else(str_detect(isolate, "health"), "Control/Healthy", "AML Patient")) %>%
  select(`Run`, condition) %>%
  mutate(sample_name = Run) %>%
  select(sample_name, condition)

sample_table

```

```{r}
sample_files <- paste0(pull(sample_table, 
            sample_name), '_quant/quant.sf')

sample_files <- paste0("../data/quants/", sample_files)

#paste0(sample_files, '_quant/quant.sf')

gene_map <- read_csv('../data/gene_map.csv', 
                     col_names = c('enstid', 'ensgid'))

names(sample_files) <- pull(sample_table, sample_name)


count_data <- tximport(files = sample_files,
                       type = 'salmon', 
                       tx2gene = gene_map,
                       ignoreTxVersion = TRUE)

# peek out counts data (non-normalized) and trancript - gene map
count_data$counts %>% head(10)
```

```{r}
gene_map %>% head(10)
```
## Load the quant data and sample information into DESeq2 datatype, and run the DESeq2 normalization
```{r}
sample_table$condition <- factor((c('AML', 'AML', 'AML', 'AML', 'Healthy',
                                         'Healthy', 'AML', 'AML', 'Healthy', 'Healthy',
                                         'Healthy', 'Healthy', 'Healthy', 'AML', 'AML')),
                                      levels = c('Healthy', 'AML'))

dds_aml <- DESeqDataSetFromTximport(txi = count_data,
                                     colData = sample_table,
                                     design = ~condition)

# Normalization - median of ratios method TTM DESeq2
dds_aml <- estimateSizeFactors(dds_aml)
#normalizationFactors(dds_aml)
counts(dds_aml, normalized = T) %>% head(10)
```
## Principal Component Analysis
```{r}
# Transform the data so it is suitable for PCA
vst_aml <- varianceStabilizingTransformation(dds_aml)
# create matrix
vst_mat <- assay(vst_aml)

pca <- prcomp(t(vst_mat)) # to calculate PCA

# plot out the data frame to produce PCA
df <- as.data.frame(pca$x)
df$condition <- sample_table$condition

pve <- round(pca$sdev^2/sum(pca$sdev^2) * 100, 2)

rownames_to_column(df, var = "sample_name") %>% as.tibble() %>%
  ggplot(., aes(x=PC1, y=PC2, color = condition)) +
  geom_point(size = 4) +
  #geom_text(aes(label = sample_name, color = condition), vjust = -1, size = 4) +
  xlab(label = paste0("PC1 (", pve[1], "%)")) +
  ylab(label = paste0("PC2 (", pve[2], "%)")) +
  theme_classic() +
  ggtitle("Principal Component Analysis")
```
```{r}

library(ggplot2)
ggsave("../figures/heatmap.png")

```


Healthy samples cluster closely together on the right side, forming a
tight group distinct from the AML patient samples. AML samples appear to
form two separate clusters along the PC2 axis (13.64% variance
explained). Additionally, two overlapping healthy samples are
represented by a single point so that we only see five dots for healthy
samples.


## Heatmap

```{r}
distance <- dist(t(assay(vst_aml)))
distance_matrix <- as.matrix(distance)
rownames(distance_matrix) <- vst_aml$condition
colnames(distance_matrix) <- vst_aml$condition
colors <- colorRampPalette( rev(brewer.pal(9, "Reds")) )(255)

pheatmap(distance_matrix,
         clustering_distance_rows=distance,
         clustering_distance_cols=distance,
         col=colors)

```


```{r}
library(ggplot2)
ggsave("../figures/heatmap.png")
```


```{r}
distance <- dist(t(assay(vst_aml)))
distance_matrix <- as.matrix(distance)
rownames(distance_matrix) <- vst_aml$condition
colnames(distance_matrix) <- vst_aml$sample_name
colors <- colorRampPalette( rev(brewer.pal(9, "Reds")) )(255)

pheatmap(distance_matrix,
         clustering_distance_rows=distance,
         clustering_distance_cols=distance,
         col=colors)
```

Comnfirmed with the heatmap, two dots consist of two samples that very
very similiar. Is that come from same person but different processed
samples (technical replicates)?



## Data Normalization with DESeq2

```{r}
# Normalize Gene Expression Data
# dds <- DESeq(dds)

# Extract Normalized Counts
# normalized_counts <- counts(dds, normalized = TRUE)
# head(normalized_counts)

# Variance Stabilizing Transformation (VST)
# vsd <- vst(dds, blind = FALSE)
# rlog_data <- rlog(dds, blind = FALSE)  # Optional if you prefer rlog

```

## Verify normalization
```{r}
# Plot a PCA (ERROR HERE)
#plotPCA(vsd, intgroup = "condition")

# Heatmap: Use the normalized counts or VST-transformed data to generate a heatmap to check for clustering:
#top_var_genes <- head(order(rowVars(assay(vsd)), decreasing = TRUE), 500)

# Check and convert data to numeric if needed
#numeric_data <- as.matrix(apply(assay(vsd)[top_var_genes, ], 2, as.numeric))



# Plot the heatmap with numeric data
# Ensure required libraries are loaded
#library(pheatmap)
#library(RColorBrewer)

# Compute the distance matrix for samples
#distance <- dist(t(assay(vst_aml)))
#distance_matrix <- as.matrix(distance)

# Ensure the row and column names are properly assigned
#rownames(distance_matrix) <- vst_aml$condition  # Adjust as needed (e.g., sample IDs or conditions)
#colnames(distance_matrix) <- colnames(vst_aml)  # Use sample names if available

# Define color palette for heatmap
#colors <- colorRampPalette(rev(brewer.pal(9, "Reds")))(255)

# Plot the heatmap
#pheatmap(distance_matrix,
        # clustering_distance_rows = distance,
       #  clustering_distance_cols = distance,
       #  col = colors,
        # main = "Sample Clustering Heatmap")


```


```{r}
library(ggplot2)
ggsave("../figures/heatmap_normalized.png")
```
# PCA Plot Interpretation
1. Variance and Clustering: The PCA plot shows how samples cluster based on their gene expression profiles. In your plot, there are clear groupings where the AML and Healthy samples cluster separately. This indicates that there are distinct expression patterns between the AML and Healthy groups, which is an essential first step to validate the biological differences in your dataset.

2. Principal Components: The first principal component (PC1), which explains 58% of the variance, suggests that the majority of the differences in gene expression can be attributed to the separation between the AML and Healthy samples. PC2, contributing 15% of the variance, provides additional information that might represent other, more subtle differences within the groups.

3. Separation: The clear separation between the AML and Healthy groups supports the notion that these two conditions have distinct transcriptomic profiles, which is expected for comparing disease states with controls.

# Heatmap Interpretation
1. Clustering Pattern: The heatmap visualizes the hierarchical clustering of samples based on their expression data. The clustering confirms the PCA plot results, showing that the samples group into two main clusters: one for AML and one for Healthy.

2. Distance Metric: The use of color intensity indicates the level of similarity between the samples. Samples within the same condition (AML or Healthy) are more similar to each other, as shown by the darker color blocks along the diagonal within groups.

3. Expression Variability: The heatmap uses VST-transformed data, which normalizes expression levels and helps highlight high-variance genes across samples. The clear separation between the two groups again underscores the differences in gene expression between AML and Healthy individuals.



## Differential Expression Analysis

# Run DESeq2 Analysis
```{r}
library(DESeq2)

# Run the DESeq function to perform differential expression analysis
dds <- DESeqDataSetFromTximport(txi = count_data,
                                     colData = sample_table,
                                     design = ~condition)
dds <- DESeq(dds)

# Obtain results for differential expression analysis
res <- results(dds)

# Order results by adjusted p-value (FDR)
resOrdered <- res[order(res$padj), ]

# Print summary of results
summary(res)

# Filter for significant DEGs     # look for treshold references
significant_DEGs <- subset(resOrdered, padj < 0.05 & abs(log2FoldChange) > 2)

# Print the number of significant DEGs found
print(paste("Number of significant DEGs:", nrow(significant_DEGs)))

```


# Visualize Differential Expression Results

MA Plot
```{r}
# MA plot to visualize log fold changes
plotMA(res, ylim = c(-5, 5), main = "MA Plot of DEGs")

# notes:
# points below mean genes
# minus log2fold change mean
# blue dots 
# the smaller mean, the bigger p-adjusted value (to eliminate false positives) 


library(ggplot2)
ggsave("../figures/MAPlot_DEGs.png")

```
```{r}



```


Volcano Plot
```{r}
# Load ggplot2 for more detailed plotting
library(ggplot2)

# Create a volcano plot
volcano_data <- as.data.frame(res)
volcano_data$significant <- ifelse(volcano_data$padj < 0.05 & abs(volcano_data$log2FoldChange) > 2, "Significant", "Not Significant")

ggplot(volcano_data, aes(x = log2FoldChange, y = -log10(padj), color = significant)) +
  geom_point(alpha = 0.6) +
  scale_color_manual(values = c("red", "blue")) +
  theme_minimal() +
  ggtitle("Volcano Plot of DEGs") +
  xlab("Log2 Fold Change") +
  ylab("-Log10 Adjusted p-value")


library(ggplot2)
ggsave("../figures/VolcanoPlot_DEGs.png")
```

# Save DEGs for Functional Analysis
```{r}
# Save significant DEGs to a CSV file for further analysis
write.csv(significant_DEGs, file = "significant_DEGs.csv", row.names = TRUE)
```



## Functional Annotation of DEGs

# Pathway Analysis
```{r}
# NOTE:
# Require annotation using ENSEMBL Biomark, enrich
# ClusterProfiler R package
# Biological process changed in AML bcs of AML, gene list of disturbed metabolisms to select drug target


if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

# Install clusterProfiler and annotation packages
BiocManager::install("clusterProfiler") # from Yu Lab
BiocManager::install("org.Hs.eg.db")  # Human annotation database
BiocManager::install("DOSE")          # For additional analysis options


library(clusterProfiler)
library(org.Hs.eg.db)
library(DOSE)  # optional for visualizations or disease ontology

# DEG List
# Extract Enseml IDs
gene_list <- significant_DEGs$...1  

library(org.Hs.eg.db)
entrez_ids <- bitr(gene_list, fromType = "ENSEMBL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)

print(entrez_ids)
```

# Prepare DEG List for Analysis
```{r}
# Extract the Entrez IDs from the conversion result
gene_list <- entrez_ids$ENTREZID
gene_list
```

# Perform Gene Ontology GO (Enrichment Analysis)
```{r}
# Load clusterProfiler and perform GO enrichment analysis
library(clusterProfiler)

go_enrich <- enrichGO(
    gene         = gene_list,
    OrgDb        = org.Hs.eg.db,    # Human annotation database
    keyType      = "ENTREZID",      # Identifier type
    ont          = "BP",            # Ontology: "BP" for Biological Process, "CC" for Cellular Component, "MF" for Molecular Function
    pAdjustMethod = "BH",           # p-value adjustment method
    pvalueCutoff  = 0.05,           # p-value cutoff for significance
    qvalueCutoff  = 0.2,            # q-value cutoff
    readable     = TRUE             # Converts Entrez IDs to gene symbols in results
)

# View the first few results
head(go_enrich)
```

# Perform KEGG Pathway Enrichment Analysis
```{r}
# Perform KEGG pathway enrichment analysis
kegg_enrich <- enrichKEGG(
    gene         = gene_list,
    organism     = "hsa",  # "hsa" for human
    pAdjustMethod = "BH",  # Benjamini-Hochberg, a method for controlling the false discovery rate (FDR) when performing multiple hypothesis tests
    pvalueCutoff  = 0.05,
    qvalueCutoff  = 0.2
)

# View the first few results
head(kegg_enrich)
```

# Visualize the results

1. GO Enrichment Analysis Result
```{r}
# Dot plot for GO enrichment analysis
library(stringr)
go_enrich@result$Description <- str_wrap(go_enrich@result$Description, width = 80)

dotplot(go_enrich, showCategory = 20) +
  ggtitle("GO Enrichment Analysis for DEGs") +
  xlab("Adjusted P-value") +
  ylab("GO Terms") +
  theme(
    axis.text.y = element_text(size = 8),   # Adjust y-axis font size
    axis.text.x = element_text(size = 12),   # Adjust x-axis font size
    plot.title = element_text(size = 14, face = "bold")
  )

#dotplot(go_enrich, showCategory = 20) +
 # theme(axis.text.y = element_text(angle = 0, hjust = 1, size = 10))

  
library(ggplot2)
ggsave("../figures/GO_enrichment_analysis.png", width = 12, height = 10, dpi = 300)

```

2. KEGG Pathway Analysis Result
```{r}
# Bar plot for KEGG pathway analysis
barplot(kegg_enrich, showCategory = 20) +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 12),
    axis.text.x = element_text(size = 10),
    plot.title = element_text(size = 14),
    axis.title.x = element_text(size = 12),
    axis.title.y = element_text(size = 12)
  )
library(ggplot2)


ggsave("../figures/KEGG_pathway_analysis.png", width = 12, height = 8, dpi = 300)
```

3. Enrichment Map Result
```{r}
# Enrichment map (optional)
if (!requireNamespace("enrichplot", quietly = TRUE))
    install.packages("enrichplot")

library(enrichplot)

# Calculate the term similarity matrix
go_enrich <- pairwise_termsim(go_enrich)

# Create the enrichment map plot
emapplot(go_enrich, showCategory = 25, cex_label_category = 1.5, repel = TRUE, layout = "fr") 

# "fr" Fruchterman-Reingold algorithm helps create a more spaced-out, visually appealing graph, especially useful when you have many terms or nodes to display.
  
  

library(ggplot2)
ggsave("../figures/Enrichment_map.png", width = 20, height = 14, dpi = 300)
```


```{r}
