---
title: "AML code"
output: html_document
date: "2024-11-03"
---

Exploring transcript data profile of healthy and AML patient samples
## Loading the required libraries
```{r}

library(ggplot2)
library(tximport)
library(tidyverse)
library(DESeq2)
library(RColorBrewer)
library(pheatmap)
```
## Loading the data

Prepare the sample table of the experiment and load quant data generated
by Salmon into R
```{r}
sample_table <- read_csv("../data/SRP518774_metadata.txt") %>%
  filter(`Assay Type` == "RNA-Seq") %>%
  select(`Run`, `isolate`) %>%
  mutate(condition = if_else(str_detect(isolate, "health"), "Control/Healthy", "AML Patient")) %>%
  select(`Run`, condition) %>%
  mutate(sample_name = Run) %>%
  select(sample_name, condition)

sample_table

```

```{r}
sample_files <- paste0(pull(sample_table, 
            sample_name), '_quant/quant.sf')

sample_files <- paste0("../data/quants/", sample_files)

#paste0(sample_files, '_quant/quant.sf')

gene_map <- read_csv('../data/gene_map.csv', 
                     col_names = c('enstid', 'ensgid'))

names(sample_files) <- pull(sample_table, sample_name)


count_data <- tximport(files = sample_files,
                       type = 'salmon', 
                       tx2gene = gene_map,
                       ignoreTxVersion = TRUE)

# peek out counts data (non-normalized) and trancript - gene map
count_data$counts %>% head(10)
```

```{r}
gene_map %>% head(10)
```
## Load the quant data and sample information into DESeq2 datatype, and run the DESeq2 normalization
```{r}
sample_table$condition <- factor((c('AML', 'AML', 'AML', 'AML', 'Healthy',
                                         'Healthy', 'AML', 'AML', 'Healthy', 'Healthy',
                                         'Healthy', 'Healthy', 'Healthy', 'AML', 'AML')),
                                      levels = c('Healthy', 'AML'))

dds_aml <- DESeqDataSetFromTximport(txi = count_data,
                                     colData = sample_table,
                                     design = ~condition)

# Normalization - median of ratios method TTM DESeq2
dds_aml <- estimateSizeFactors(dds_aml)
#normalizationFactors(dds_aml)
counts(dds_aml, normalized = T) %>% head(10)
```
## Principal Component Analysis
```{r}
# Transform the data so it is suitable for PCA
vst_aml <- varianceStabilizingTransformation(dds_aml)
# create matrix
vst_mat <- assay(vst_aml)

pca <- prcomp(t(vst_mat)) # to calculate PCA

# plot out the data frame to produce PCA
df <- as.data.frame(pca$x)
df$condition <- sample_table$condition

pve <- round(pca$sdev^2/sum(pca$sdev^2) * 100, 2)

rownames_to_column(df, var = "sample_name") %>% as.tibble() %>%
  ggplot(., aes(x=PC1, y=PC2, color = condition)) +
  geom_point(size = 4) +
  #geom_text(aes(label = sample_name, color = condition), vjust = -1, size = 4) +
  xlab(label = paste0("PC1 (", pve[1], "%)")) +
  ylab(label = paste0("PC2 (", pve[2], "%)")) +
  theme_classic() +
  ggtitle("Principal Component Analysis")
```
```{r}

library(ggplot2)
ggsave("../figures/heatmap.png")

```


Healthy samples cluster closely together on the right side, forming a
tight group distinct from the AML patient samples. AML samples appear to
form two separate clusters along the PC2 axis (13.64% variance
explained). Additionally, two overlapping healthy samples are
represented by a single point so that we only see five dots for healthy
samples.


## Heatmap

```{r}
distance <- dist(t(assay(vst_aml)))
distance_matrix <- as.matrix(distance)
rownames(distance_matrix) <- vst_aml$condition
colnames(distance_matrix) <- vst_aml$condition
colors <- colorRampPalette( rev(brewer.pal(9, "Reds")) )(255)

pheatmap(distance_matrix,
         clustering_distance_rows=distance,
         clustering_distance_cols=distance,
         col=colors)

```


```{r}
library(ggplot2)
ggsave("../figures/heatmap.png")
```


```{r}
distance <- dist(t(assay(vst_aml)))
distance_matrix <- as.matrix(distance)
rownames(distance_matrix) <- vst_aml$condition
colnames(distance_matrix) <- vst_aml$sample_name
colors <- colorRampPalette( rev(brewer.pal(9, "Reds")) )(255)

pheatmap(distance_matrix,
         clustering_distance_rows=distance,
         clustering_distance_cols=distance,
         col=colors)
```

Comnfirmed with the heatmap, two dots consist of two samples that very
very similiar. Is that come from same person but different processed
samples (technical replicates)?



## Data Normalization with DESeq2

```{r}
# Normalize Gene Expression Data
# dds <- DESeq(dds)

# Extract Normalized Counts
# normalized_counts <- counts(dds, normalized = TRUE)
# head(normalized_counts)

# Variance Stabilizing Transformation (VST)
# vsd <- vst(dds, blind = FALSE)
# rlog_data <- rlog(dds, blind = FALSE)  # Optional if you prefer rlog

```

## Verify normalization
```{r}
# Plot a PCA (ERROR HERE)
#plotPCA(vsd, intgroup = "condition")

# Heatmap: Use the normalized counts or VST-transformed data to generate a heatmap to check for clustering:
#top_var_genes <- head(order(rowVars(assay(vsd)), decreasing = TRUE), 500)

# Check and convert data to numeric if needed
#numeric_data <- as.matrix(apply(assay(vsd)[top_var_genes, ], 2, as.numeric))



# Plot the heatmap with numeric data
# Ensure required libraries are loaded
#library(pheatmap)
#library(RColorBrewer)

# Compute the distance matrix for samples
#distance <- dist(t(assay(vst_aml)))
#distance_matrix <- as.matrix(distance)

# Ensure the row and column names are properly assigned
#rownames(distance_matrix) <- vst_aml$condition  # Adjust as needed (e.g., sample IDs or conditions)
#colnames(distance_matrix) <- colnames(vst_aml)  # Use sample names if available

# Define color palette for heatmap
#colors <- colorRampPalette(rev(brewer.pal(9, "Reds")))(255)

# Plot the heatmap
#pheatmap(distance_matrix,
        # clustering_distance_rows = distance,
       #  clustering_distance_cols = distance,
       #  col = colors,
        # main = "Sample Clustering Heatmap")


```


```{r}
library(ggplot2)
ggsave("../figures/heatmap_normalized.png")
```
# PCA Plot Interpretation
1. Variance and Clustering: The PCA plot shows how samples cluster based on their gene expression profiles. In your plot, there are clear groupings where the AML and Healthy samples cluster separately. This indicates that there are distinct expression patterns between the AML and Healthy groups, which is an essential first step to validate the biological differences in your dataset.

2. Principal Components: The first principal component (PC1), which explains 58% of the variance, suggests that the majority of the differences in gene expression can be attributed to the separation between the AML and Healthy samples. PC2, contributing 15% of the variance, provides additional information that might represent other, more subtle differences within the groups.

3. Separation: The clear separation between the AML and Healthy groups supports the notion that these two conditions have distinct transcriptomic profiles, which is expected for comparing disease states with controls.

# Heatmap Interpretation
1. Clustering Pattern: The heatmap visualizes the hierarchical clustering of samples based on their expression data. The clustering confirms the PCA plot results, showing that the samples group into two main clusters: one for AML and one for Healthy.

2. Distance Metric: The use of color intensity indicates the level of similarity between the samples. Samples within the same condition (AML or Healthy) are more similar to each other, as shown by the darker color blocks along the diagonal within groups.

3. Expression Variability: The heatmap uses VST-transformed data, which normalizes expression levels and helps highlight high-variance genes across samples. The clear separation between the two groups again underscores the differences in gene expression between AML and Healthy individuals.



## Differential Expression Analysis

# Run DESeq2 Analysis
```{r}
library(DESeq2)

# Run the DESeq function to perform differential expression analysis
dds <- DESeqDataSetFromTximport(txi = count_data,
                                     colData = sample_table,
                                     design = ~condition)
dds <- DESeq(dds)

# Obtain results for differential expression analysis
res <- results(dds)

# Order results by adjusted p-value (FDR)
resOrdered <- res[order(res$padj), ]

# Print summary of results
summary(res)

# Filter for significant DEGs     # look for treshold references
significant_DEGs <- subset(resOrdered, padj < 0.05 & abs(log2FoldChange) > 2)

# Print the number of significant DEGs found
print(paste("Number of significant DEGs:", nrow(significant_DEGs)))

```


# Visualize Differential Expression Results

MA Plot
```{r}
# MA plot to visualize log fold changes
plotMA(res, ylim = c(-5, 5), main = "MA Plot of DEGs")

# notes:
# points below mean genes
# minus log2fold change mean
# blue dots 
# the smaller mean, the bigger p-adjusted value (to eliminate false positives) 


library(ggplot2)
ggsave("../figures/MAPlot_DEGs.png")

```
```{r}



```


Volcano Plot
```{r}
# Load ggplot2 for more detailed plotting
library(ggplot2)

# Create a volcano plot
volcano_data <- as.data.frame(res)
volcano_data$significant <- ifelse(volcano_data$padj < 0.05 & abs(volcano_data$log2FoldChange) > 2, "Significant", "Not Significant")

ggplot(volcano_data, aes(x = log2FoldChange, y = -log10(padj), color = significant)) +
  geom_point(alpha = 0.6) +
  scale_color_manual(values = c("red", "blue")) +
  theme_minimal() +
  ggtitle("Volcano Plot of DEGs") +
  xlab("Log2 Fold Change") +
  ylab("-Log10 Adjusted p-value")


library(ggplot2)
ggsave("../figures/VolcanoPlot_DEGs.png")
```

# Save DEGs for Functional Analysis
```{r}
# Save significant DEGs to a CSV file for further analysis
write.csv(significant_DEGs, file = "significant_DEGs.csv", row.names = TRUE)
```



## Functional Annotation of DEGs

# Pathway Analysis
```{r}
# NOTE:
# Require annotation using ENSEMBL Biomark, enrich
# ClusterProfiler R package
# Biological process changed in AML bcs of AML, gene list of disturbed metabolisms to select drug target


if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

# Install clusterProfiler and annotation packages
BiocManager::install("clusterProfiler") # from Yu Lab
BiocManager::install("org.Hs.eg.db")  # Human annotation database
BiocManager::install("DOSE")          # For additional analysis options


library(clusterProfiler)
library(org.Hs.eg.db)
library(DOSE)  # optional for visualizations or disease ontology

# DEG List
# Extract Enseml IDs
gene_list <- significant_DEGs$...1  

library(org.Hs.eg.db)
entrez_ids <- bitr(gene_list, fromType = "ENSEMBL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)

print(entrez_ids)
```

# Prepare DEG List for Analysis
```{r}
# Extract the Entrez IDs from the conversion result
gene_list <- entrez_ids$ENTREZID
gene_list
```

# Perform Gene Ontology GO (Enrichment Analysis)
```{r}
# Load clusterProfiler and perform GO enrichment analysis
library(clusterProfiler)

go_enrich <- enrichGO(
    gene         = gene_list,
    OrgDb        = org.Hs.eg.db,    # Human annotation database
    keyType      = "ENTREZID",      # Identifier type
    ont          = "BP",            # Ontology: "BP" for Biological Process, "CC" for Cellular Component, "MF" for Molecular Function
    pAdjustMethod = "BH",           # p-value adjustment method
    pvalueCutoff  = 0.05,           # p-value cutoff for significance
    qvalueCutoff  = 0.2,            # q-value cutoff
    readable     = TRUE             # Converts Entrez IDs to gene symbols in results
)

# View the first few results
head(go_enrich)
```

# Perform KEGG Pathway Enrichment Analysis
```{r}
# Perform KEGG pathway enrichment analysis
kegg_enrich <- enrichKEGG(
    gene         = gene_list,
    organism     = "hsa",  # "hsa" for human
    pAdjustMethod = "BH",  # Benjamini-Hochberg, a method for controlling the false discovery rate (FDR) when performing multiple hypothesis tests
    pvalueCutoff  = 0.05,
    qvalueCutoff  = 0.2
)

# View the first few results
head(kegg_enrich)
```

# Visualize the results

1. GO Enrichment Analysis Result
```{r}
# Dot plot for GO enrichment analysis
library(stringr)
go_enrich@result$Description <- str_wrap(go_enrich@result$Description, width = 80)

dotplot(go_enrich, showCategory = 20) +
  ggtitle("GO Enrichment Analysis for DEGs") +
  xlab("Adjusted P-value") +
  ylab("GO Terms") +
  theme(
    axis.text.y = element_text(size = 8),   # Adjust y-axis font size
    axis.text.x = element_text(size = 12),   # Adjust x-axis font size
    plot.title = element_text(size = 14, face = "bold")
  )

#dotplot(go_enrich, showCategory = 20) +
 # theme(axis.text.y = element_text(angle = 0, hjust = 1, size = 10))

  
library(ggplot2)
ggsave("../figures/GO_enrichment_analysis.png", width = 12, height = 10, dpi = 300)

```

2. KEGG Pathway Analysis Result
```{r}
# Bar plot for KEGG pathway analysis
barplot(kegg_enrich, showCategory = 20) +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 12),
    axis.text.x = element_text(size = 10),
    plot.title = element_text(size = 14),
    axis.title.x = element_text(size = 12),
    axis.title.y = element_text(size = 12)
  )
library(ggplot2)


ggsave("../figures/KEGG_pathway_analysis.png", width = 12, height = 8, dpi = 300)
```

3. Enrichment Map Result
```{r}
# Enrichment map (optional)
if (!requireNamespace("enrichplot", quietly = TRUE))
    install.packages("enrichplot")

library(enrichplot)

# Calculate the term similarity matrix
go_enrich <- pairwise_termsim(go_enrich)

# Create the enrichment map plot
emapplot(go_enrich, showCategory = 25, cex_label_category = 1.5, repel = TRUE, layout = "fr") 

# "fr" Fruchterman-Reingold algorithm helps create a more spaced-out, visually appealing graph, especially useful when you have many terms or nodes to display.
  
  

library(ggplot2)
ggsave("../figures/Enrichment_map.png", width = 20, height = 14, dpi = 300)
```

DRUG REPURPOSING
1. Analyzing Differentially Expressed Genes (DEGs)
1.1 Filter DEGs based on significance criteria
```{r}
# `res` is the DESeq2 results object
significant_DEGs <- res[which(res$padj < 0.05 & abs(res$log2FoldChange) > 2), ]

# A common threshold is adjusted p-value < 0.05, meaning only genes with strong statistical evidence are retained.
# A threshold of log2 fold change > ±2 is often used to focus on genes with biologically meaningful differences in expression.

# Convert to data frame and sort by log2 fold change
significant_DEGs_df <- as.data.frame(significant_DEGs)
significant_DEGs_df <- significant_DEGs_df[order(significant_DEGs_df$log2FoldChange, decreasing = TRUE), ]

# View the top results
head(significant_DEGs_df)

# convert significant_DEGs to a data frame and sort by log2 fold change to see the top upregulated and downregulated genes.
significant_DEGs_df <- as.data.frame(significant_DEGs)
significant_DEGs_df <- significant_DEGs_df[order(significant_DEGs_df$log2FoldChange, decreasing = TRUE), ]

# View the top results
head(significant_DEGs_df)

cat("Number of significant DEGs: ", nrow(significant_DEGs_df), "\n")
# output: Number of significant DEGs:  8112 
```

1.2 Inspect Top Upregulated and Downregulated Genes
Upregulated genes might include potential oncogenes, 
while downregulated genes may reveal suppressed tumor suppressor pathways.
```{r}
## Extract upregulated and downregulated genes:
# Upregulated genes (positive log2 fold change)
upregulated_genes <- significant_DEGs_df[significant_DEGs_df$log2FoldChange > 0, ]

# Downregulated genes (negative log2 fold change)
downregulated_genes <- significant_DEGs_df[significant_DEGs_df$log2FoldChange < 0, ]

## View top genes
# view the top 10 upregulated and downregulated genes to gain insights into specific genes that might play roles in AML.
# Top 10 Upregulated Genes
cat("Top 10 Upregulated Genes:\n")
head(upregulated_genes, 10)

# Top 10 Downregulated Genes
cat("Top 10 Downregulated Genes:\n")
head(downregulated_genes, 10)

# Plot histogram of log2 fold changes
# to visualize the spread of gene expression differences between AML and healthy samples.
hist(significant_DEGs_df$log2FoldChange, breaks = 50, col = "skyblue",
     main = "Log2 Fold Change Distribution", xlab = "Log2 Fold Change")
```

Filter and Prioritize Genes Based on Relevance to AML
```{r}
# Load necessary libraries
library(dplyr)
library(magrittr)

# Convert to data frame if not already
significant_DEGs_df <- as.data.frame(significant_DEGs)

# Move rownames (gene IDs) to a new column called 'gene_name'
significant_DEGs_df <- significant_DEGs_df %>%
  dplyr::mutate(gene_name = rownames(significant_DEGs_df)) %>%
  dplyr::select(gene_name, log2FoldChange, padj)

# Filter for top DEGs with |log2FoldChange| > 2
top_DEGs_summary <- significant_DEGs_df %>%
  dplyr::filter(log2FoldChange > 2 | log2FoldChange < -2)

# Print the summary table
print(top_DEGs_summary)

```

Identify Potential Target Genes
```{r}
# Load necessary libraries
if (!requireNamespace("clusterProfiler", quietly = TRUE)) {
    install.packages("clusterProfiler")
}
library(clusterProfiler)

# Ensure that you have your organism database loaded, for instance, org.Hs.eg.db for human
if (!requireNamespace("org.Hs.eg.db", quietly = TRUE)) {
    BiocManager::install("org.Hs.eg.db")
}
library(org.Hs.eg.db)

# Assuming `gene_list` contains your significant DEGs in ENTREZ ID format
enrich_kegg_results <- enrichKEGG(gene = gene_list, organism = "hsa", pvalueCutoff = 0.05)

```

Pathway and Network Analysis
```{r}
kegg_df <- as.data.frame(enrich_kegg_results)
#head(kegg_df)  # View the top rows to inspect the enrichment results

# Filter for specific pathways
target_pathways <- kegg_df %>%
    filter(Description %in% c("PI3K-Akt signaling pathway", "JAK-STAT signaling pathway", "Cytokine-cytokine receptor interaction"))
print(target_pathways)


```
```{r}
pathway_genes <- target_pathways %>%
   pull(geneID) %>%
   strsplit("/") %>%
   unlist() %>%
   unique()  # Remove duplicates

print(pathway_genes)

```

Convert Gene IDs to Gene Symbols (if needed)
Some drug-gene databases, like DGIdb, may require gene symbols instead of KEGG IDs. Use a conversion tool if your gene IDs are in KEGG format.
```{r}
library(org.Hs.eg.db)
pathway_genes_symbols <- mapIds(org.Hs.eg.db, keys = pathway_genes,
                                column = "SYMBOL", keytype = "ENTREZID", multiVals = "first")
pathway_genes_symbols <- na.omit(pathway_genes_symbols)  # Remove any NAs
print(pathway_genes_symbols)
```


```{r}
# Export gene symbols to a CSV file for manual upload
write.csv(data.frame(GeneSymbol = pathway_genes_symbols), "pathway_genes_symbols.csv", row.names = FALSE)

```




Filter gene list from DGIdb by Interaction Type (do we use this/no?)
```{r}
# Load necessary libraries
library(dplyr)

list.files(recursive = TRUE)

# Read in the DGIdb data
dgidb_data <- read.delim("gene_interaction_results-11_6_2024.tsv", sep = "\t")
head(dgidb_data)


# View column names
colnames(dgidb_data)
# View the first few rows of the data
head(dgidb_data)

```

identify All High-Score Interactions 
```{r}
high_score_data <- dgidb_data %>%
    filter(interaction.score > 1)  # Adjust threshold based on what’s considered "high"
print(head(high_score_data))
```
else
```{r}
# Group by drug type or indication if those are available
summary_by_approval <- dgidb_data %>%
    group_by(regulatory.approval) %>%
    summarise(Count = n())
print(summary_by_approval)

# Group by indication if it's available
summary_by_indication <- dgidb_data %>%
    group_by(indication) %>%
    summarise(Count = n())
print(summary_by_indication)

drug_summary <- dgidb_data %>%
    group_by(drug) %>%
    summarise(Targeted_Genes = paste(unique(gene), collapse = ", "),
              Count = n()) %>%
    arrange(desc(Count))
print(head(drug_summary))


```


```{r}
write.csv(dgidb_data, "filtered_dgidb_data.csv", row.names = FALSE)
```

Analyze Top Drugs by Targeted Genes
```{r}
# Filter for drugs that target more than 5 genes as an example
multi_target_drugs <- drug_summary %>%
    filter(Count > 5)
print(multi_target_drugs)
```

Assess Approved vs. Unapproved Drugs
```{r}
# Filter for only approved drugs, if that’s your focus
approved_drugs <- dgidb_data %>%
    filter(regulatory.approval == "Approved")
print(approved_drugs)

```
```{r}
# View the most common indications
print(head(summary_by_indication, 10))

```
```{r}
# Bar Plot of Top Multi-Target Drugs: Shows which drugs target the most genes.
# Pie Chart of Drug Approval Status: Visualizes the distribution of approved vs. unapproved drugs.
# Bar Plot of Common Indications: Shows the top indications for the drugs in your dataset.

library(ggplot2)

# Top multi-target drugs plot
ggplot(multi_target_drugs, aes(x = reorder(drug, -Count), y = Count)) +
    geom_bar(stat = "identity") +
    labs(title = "Top Multi-Target Drugs", x = "Drug", y = "Number of Genes Targeted") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggsave("../figures/top_multi target_drugs_plot.png")

# Pie chart for regulatory approval
ggplot(summary_by_approval, aes(x = "", y = Count, fill = regulatory.approval)) +
    geom_bar(stat = "identity", width = 1) +
    coord_polar("y") +
    labs(title = "Drug Approval Status") +
    theme_void()

ggsave("../figures/piechart_regulatoryapproval.png")

# Bar plot for indications
ggplot(head(summary_by_indication, 10), aes(x = reorder(indication, -Count), y = Count)) +
    geom_bar(stat = "identity") +
    labs(title = "Top Drug Indications", x = "Indication", y = "Count") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
ggsave("../figures/barplot_indications.png")

# Filter for approved drugs with high interaction scores
approved_drugs <- dgidb_data %>%
    filter(regulatory.approval == "Approved" & interaction.score > 0.5) %>%
    arrange(desc(interaction.score))
print(head(approved_drugs))  # View top approved drugs with strong interactions


```
```{r}
write.csv(drug_summary, "drug_summary.csv", row.names = FALSE)
write.csv(summary_by_approval, "summary_by_approval.csv", row.names = FALSE)
write.csv(summary_by_indication, "summary_by_indication.csv", row.names = FALSE)
write.csv(approved_drugs, "approved_drugs.csv", row.names = FALSE)
```



A list of genes per drug
```{r}

library(dplyr)

# Group by drug and create a list of genes targeted by each drug
genes_per_drug <- dgidb_data %>%
    group_by(drug) %>%
    summarise(Targeted_Genes = paste(unique(gene), collapse = ", "))

print(genes_per_drug)

# Save the result to a CSV file 
write.csv(genes_per_drug, "genes_per_drug.csv", row.names = FALSE)


```




